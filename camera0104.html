<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>
  @import url("resources/webgl-tutorials.css");
   body {
     margin: 0;
   }
   canvas {
     display: block;  /* prevents scrollbar */
     width: 100vw;
     height: 100vh;
   }
   
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="uiContainer">
  <div id="ui">
    <div id="targetAngle"></div>
    <div id="targetRadius"></div>
    <div id="targetHeight"></div>
    <div id="cameraVerticalDeg"></div>
    <div id="cameraHorizontalDeg"></div>
  </div>
</div>
</body>

<script src="resources/webgl-utils.js"></script>
<script src="resources/webgl-lessons-ui.js"></script>
<script src="resources/headdata.js"></script>
<script src="resources/m4.js"></script>
<script>
"use strict";

var vertexShaderSource = `#version 300 es
in vec4 a_position;
in vec4 a_color;

uniform mat4 u_matrix;

out vec4 v_color;

void main() {
  gl_Position = u_matrix * a_position;
  v_color = a_color;
}
`;

var fragmentShaderSource = `#version 300 es
precision highp float;

in vec4 v_color;

out vec4 outColor;

void main() {
  outColor = v_color;
}
`;

var vs = `#version 300 es
in vec4 a_texposition;
in vec2 a_texcoord;
in vec3 a_normal;

uniform vec3 u_lightWorldPosition;
uniform vec3 u_viewWorldPosition;

uniform mat4 u_world;
uniform mat4 u_worldViewProjection;     //uniform mat4 u_texmatrix;
uniform mat4 u_worldInverseTranspose;

out vec3 v_normal;
out vec3 v_surfaceToLight;
out vec3 v_surfaceToView;

out vec2 v_texcoord;

void main() {
  gl_Position = u_worldViewProjection * a_texposition;
  //v_normal = mat3(u_worldInverseTranspose) * a_normal;
  v_normal = mat3(u_worldViewProjection) * a_normal;
  vec3 surfaceWorldPosition = (u_world * a_texposition).xyz;
  v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
  v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;

  v_texcoord = a_texcoord;
}
`;

var fs = `#version 300 es

precision highp float;

in vec2 v_texcoord;

in vec3 v_normal;
in vec3 v_surfaceToLight;
in vec3 v_surfaceToView;

uniform sampler2D u_texture;  //u_color
uniform float u_shininess;
uniform vec3 u_lightDirection;
uniform float u_innerLimit;          // in dot space
uniform float u_outerLimit;          // in dot space

out vec4 outTexture;  //outcolor

void main() {
  vec3 normal = normalize(v_normal);
  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
  
  float dotFromDirection = dot(surfaceToLightDirection, -u_lightDirection);

  float limitRange = u_innerLimit - u_outerLimit;
  float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
  float light = inLight * dot(normal, surfaceToLightDirection);
  float specular = inLight * pow(dot(normal, halfVector), u_shininess);

 

  outTexture = texture(u_texture, v_texcoord);
  outTexture.rgb *= light;
  outTexture.rgb += specular;
}
`;


function main() {
  var canvas = document.querySelector("#canvas");
  var gl = canvas.getContext("webgl2");
  var program = webglUtils.createProgramFromSources(gl, [vertexShaderSource, fragmentShaderSource]);
  var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
  var colorAttributeLocation = gl.getAttribLocation(program, "a_color");
  var matrixLocation = gl.getUniformLocation(program, "u_matrix");


  var texprogram = webglUtils.createProgramFromSources(gl, [vs, fs]);
  var texpositionAttributeLocation = gl.getAttribLocation(texprogram, "a_texposition");
  var texcoordAttributeLocation = gl.getAttribLocation(texprogram, "a_texcoord");
  var normalAttributeLocation = gl.getAttribLocation(texprogram, "a_normal");
  
  //var texmatrixLocation = gl.getUniformLocation(texprogram, "u_texmatrix");
  var worldViewProjectionLocation = gl.getUniformLocation(texprogram, "u_worldViewProjection");  //uniform mat4 u_texmatrix;
  var worldInverseTransposeLocation = gl.getUniformLocation(texprogram, "u_worldInverseTranspose");
  var shininessLocation = gl.getUniformLocation(texprogram, "u_shininess");
  var lightDirectionLocation = gl.getUniformLocation(texprogram, "u_lightDirection");
  var innerLimitLocation = gl.getUniformLocation(texprogram, "u_innerLimit");
  var outerLimitLocation = gl.getUniformLocation(texprogram, "u_outerLimit");
  var lightWorldPositionLocation = gl.getUniformLocation(texprogram, "u_lightWorldPosition");
  var viewWorldPositionLocation = gl.getUniformLocation(texprogram, "u_viewWorldPosition");
  var worldLocation = gl.getUniformLocation(texprogram, "u_world");



  var vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  /*---position---*/
  var positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  setGeometry(gl);
  var numVertices = 10;                //!!!numVertices
  var numSL = 12;
  gl.enableVertexAttribArray(positionAttributeLocation);

  var size = 3;
  var type = gl.FLOAT;
  var normalize = false;
  var stride = 0;
  var offset = 0;
  gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);


  /*---color---*/
  var colorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  setColors(gl);
  gl.enableVertexAttribArray(colorAttributeLocation);
  var size = 3;
  var type = gl.UNSIGNED_BYTE;
  var normalize = true;
  var stride = 0;
  var offset = 0;
  gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);



  /*---texture position---*/
  var texpositionBuffer = gl.createBuffer();
  var texvao = gl.createVertexArray();
  gl.bindVertexArray(texvao);
  gl.enableVertexAttribArray(texpositionAttributeLocation);
  gl.bindBuffer(gl.ARRAY_BUFFER, texpositionBuffer);
  setTexGeometry(gl);
  var size = 3;          // 3 components per iteration
  var type = gl.FLOAT;   // the data is 32bit floats
  var normalize = false; // don't normalize the data
  var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
  var offset = 0;        // start at the beginning of the buffer
  gl.vertexAttribPointer(texpositionAttributeLocation, size, type, normalize, stride, offset);


  /*---texture coordinates---*/
  var texcoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
  var texcoords = [
    1, 1,
    1, 0,
    0, 1,
    0, 0,
    0, 1,
    1, 0,
    1, 1,
    0, 1,
    1, 0,
    0, 0,
    1, 0,
    0, 1,
  ];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texcoordAttributeLocation);
  var size = 2;          // 2 components per iteration
  var type = gl.FLOAT;   // the data is 32bit floating point values
  var normalize = true;  // convert from 0-255 to 0.0-1.0
  var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next color
  var offset = 0;        // start at the beginning of the buffer
  gl.vertexAttribPointer(texcoordAttributeLocation, size, type, normalize, stride, offset);


  /*---normal---*/
  var normalBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  var nornals = new Float32Array([ 
    0,1,0,
    0,1,0, 
    0,1,0, 
    0,1,0, 
    0,1,0, 
    0,1,0, 
    0,-1,0,
    0,-1,0, 
    0,-1,0,
    0,-1,0, 
    0,-1,0, 
    0,-1,0,
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, nornals, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(normalAttributeLocation);
  var size = 3;          // 3 components per iteration
  var type = gl.FLOAT;   // the data is 32bit floats
  var normalize = false; // don't normalize the data
  var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next color
  var offset = 0;        // start at the beginning of the buffer
  gl.vertexAttribPointer(normalAttributeLocation, size, type, normalize, stride, offset);


  /*---texture---*/
  
  var texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0 + 0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                new Uint8Array([0, 0, 0, 255]));

  //load an image
  var image = new Image();
  image.src = "resources/uv-grid.png";
  image.addEventListener('load', function() {  
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    gl.generateMipmap(gl.TEXTURE_2D);
  });


  



  function radToDeg(r) {
    return r * 180 / Math.PI;
  }

  function degToRad(d) {
    return d * Math.PI / 180;
  }


  //variables
  var target = [0, 150, 0];
  var targetAngleRadians = 0;
  var targetRadius = 300;
  target[0] = Math.sin(targetAngleRadians) * targetRadius;
  target[2] = Math.cos(targetAngleRadians) * targetRadius;

  var fieldOfViewRadians = degToRad(60);
  var cameraPosition = [0, 500, 0];
  var cameraDistance = 1000;
  var cameraVerticalRad = degToRad(30);
  var cameraHorizontalRad = degToRad(60);
  cameraPosition[0] = Math.sin(cameraHorizontalRad) * cameraDistance;
  cameraPosition[2] = Math.cos(cameraHorizontalRad) * cameraDistance;
  cameraPosition[1] = Math.sin(cameraVerticalRad) * cameraDistance;
  var cameraTarget = [0, -100, 0];
  var up = [0, 1, 0];
  var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  var zNear = 1;
  var zFar = 3000;
  var projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);

  var shininess = 128;
  var lightDirection = [0, 0, 1];  // this is computed in updateScene
  var innerLimit = degToRad(30);
  var outerLimit = degToRad(60);


  
  requestAnimationFrame(drawScene);
  requestAnimationFrame(drawTexture);


  //ui.
  webglLessonsUI.setupSlider("#targetAngle", {value: radToDeg(targetAngleRadians), slide: updateTargetAngle, min: -360, max: 360});
  webglLessonsUI.setupSlider("#targetRadius", {value: targetRadius, slide: updateTargetRadius, min: 1, max: 300});
  webglLessonsUI.setupSlider("#targetHeight", {value: target[1], slide: updateTargetHeight, min: 50, max: 300});
  webglLessonsUI.setupSlider("#cameraVerticalDeg", {value: radToDeg(cameraVerticalRad), slide: updateCameraVertical, min: 0, max: 85});
  webglLessonsUI.setupSlider("#cameraHorizontalDeg", {value: radToDeg(cameraHorizontalRad), slide: updateCameraHorizontal, min: 0, max: 360});

  function updateTargetAngle(event, ui) {
    targetAngleRadians = degToRad(ui.value);
    target[0] = Math.sin(targetAngleRadians) * targetRadius;
    target[2] = Math.cos(targetAngleRadians) * targetRadius;
    requestAnimationFrame(drawScene);
    requestAnimationFrame(drawTexture);
    
  }

  function updateTargetRadius(event, ui) {
    targetRadius = ui.value;
    target[0] = Math.sin(targetAngleRadians) * targetRadius;
    target[2] = Math.cos(targetAngleRadians) * targetRadius;
    requestAnimationFrame(drawScene);
    requestAnimationFrame(drawTexture);
  }

  function updateTargetHeight(event, ui) {
    target[1] = ui.value;
    requestAnimationFrame(drawScene);
    requestAnimationFrame(drawTexture);
  }

  function updateCameraVertical(event, ui) {
    cameraVerticalRad = degToRad(ui.value);
    cameraPosition[1] = Math.sin(cameraVerticalRad) * cameraDistance;
    requestAnimationFrame(drawScene);
    requestAnimationFrame(drawTexture);
  }

  function updateCameraHorizontal(event, ui) {
    cameraHorizontalRad = degToRad(ui.value);
    cameraPosition[0] = Math.sin(cameraHorizontalRad) * cameraDistance;
    cameraPosition[2] = Math.cos(cameraHorizontalRad) * cameraDistance;
    requestAnimationFrame(drawScene);
    requestAnimationFrame(drawTexture);
  }


 
  function drawScene() {
    webglUtils.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.useProgram(program);
    gl.bindVertexArray(vao);
    
    /*camera matrix*/
    var cameraMatrix = m4.lookAt(cameraPosition, cameraTarget, up);

    /*view matrix*/
    var viewMatrix = m4.inverse(cameraMatrix);
    var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

    // Draw heads in a grid
    var deep = 15;
    var across = 15;
    for (var zz = 0; zz < deep; ++zz) {
      var v = zz / (deep - 1);
      var z = (v - .5) * deep * 150;
      for (var xx = 0; xx < across; ++xx) {
        var u = xx / (across - 1);
        var x = (u - .5) * across * 150;
        var matrix = m4.lookAt([x, 0, z], target, up);
        drawPlane(matrix, viewProjectionMatrix, matrixLocation, numVertices);
      }
    }

    drawSpotlight(m4.translation(target[0], target[1], target[2]), viewProjectionMatrix, matrixLocation, numSL);
  }

  function drawTexture(){
    webglUtils.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    

    gl.useProgram(texprogram);
    gl.bindVertexArray(texvao);
    
    /*camera matrix*/
    var cameraMatrix = m4.lookAt(cameraPosition, cameraTarget, up);
    
    /*view matrix*/
    var viewMatrix = m4.inverse(cameraMatrix);
    var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

  
    // Draw textures
    var deep = 15;
    var across = 15;
    for (var zz = 0; zz < deep; ++zz) {
      var v = zz / (deep - 1);
      var z = (v - .5) * deep * 150;
      for (var xx = 0; xx < across; ++xx) {
        var u = xx / (across - 1);
        var x = (u - .5) * across * 150;
        var worldMatrix = m4.lookAt([x, 0, z], target, up);
        worldMatrix = m4.scale(worldMatrix, .9, .9, .9);

        
        var worldViewProjectionMatrix = m4.multiply(viewProjectionMatrix, worldMatrix);
        var worldInverseMatrix = m4.inverse(worldMatrix);
        var worldInverseTransposeMatrix = m4.transpose(worldInverseMatrix);

        gl.uniformMatrix4fv(worldViewProjectionLocation, false, worldViewProjectionMatrix);
        gl.uniformMatrix4fv(worldInverseTransposeLocation, false, worldInverseTransposeMatrix);
        gl.uniformMatrix4fv(worldLocation, false, worldMatrix);
        

        
        gl.uniform3fv(lightWorldPositionLocation, target);
        gl.uniform3fv(viewWorldPositionLocation, cameraPosition);
        gl.uniform1f(shininessLocation, shininess);

        {
          var lmat = m4.lookAt(target, cameraTarget, up);
          lightDirection = [-lmat[8], -lmat[9], -lmat[10]];
        }
        gl.uniform3fv(lightDirectionLocation, lightDirection);
        gl.uniform1f(innerLimitLocation, Math.cos(innerLimit));
        gl.uniform1f(outerLimitLocation, Math.cos(outerLimit));

      
        gl.drawArrays(gl.TRIANGLES, 0, 12);
      }
    }
  }


  function drawPlane(matrix, viewProjectionMatrix, matrixLocation, numVertices) {
    matrix = m4.multiply(viewProjectionMatrix, matrix);
    gl.uniformMatrix4fv(matrixLocation, false, matrix);
    var primitiveType = gl.LINES;
    var offset = 0;
    gl.drawArrays(primitiveType, offset, numVertices);
  }


  function drawSpotlight(matrix, viewProjectionMatrix, matrixLocation, numSL) {
    matrix = m4.lookAt(target, [0,0,0], [0,1,0]);
    matrix = m4.multiply(viewProjectionMatrix, matrix);
    matrix = m4.scale(matrix, 3, 3, 3);
    gl.uniformMatrix4fv(matrixLocation, false, matrix);
    var primitiveType = gl.LINES;
    var offset = 10;
    gl.drawArrays(primitiveType, offset, 18);
  }

}


function setGeometry(gl) {
  var positions = new Float32Array([
    -40,-40,0,
    -40,40,0,
    -40,40,0,
    40,40,0,
    40,40,0,
    -40,-40,0,
    40,40,0,
    40,-40,0,
    40,-40,0,
    -40,-40,0,

    
    //SL
    0,0,30,
    0,10,0,
    0,0,30,
    -10,0,0,
    0,0,30,
    0,-10,0,
    0,0,30,
    10,0,0,
    0,0,30,
    0,0,0,
    0,10,0,
    0,0,0,
    -10,0,0,
    0,0,0,
    0,-10,0,
    0,0,0,
    10,0,0,
    0,0,0,
  ]);

  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
}



function setColors(gl) {
  gl.bufferData(
      gl.ARRAY_BUFFER,
      new Uint8Array([
        //plane
        0,0,0,
        0,0,0,
        0,0,0,
        0,0,0,
        0,0,0,
        0,0,0,
        0,0,0,
        0,0,0,
        0,0,0,
        0,0,0,
        //spotlight
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
        255, 0, 0,
      ]),
      gl.STATIC_DRAW);
}

function setTexGeometry(gl){
  var texpositions = new Float32Array([
    -40,  -40,  0,
    -40, 40,  0,
    40, -40,  0,
    40, 40,  0,
    40, -40,  0,
    -40, 40,  0,

    -40,  -40,  0,
    40, -40,  0,
    -40, 40,  0,

    40, 40,  0,
    -40, 40,  0,
    40, -40,  0,
    
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, texpositions, gl.STATIC_DRAW);
}


main();
</script>
</html>